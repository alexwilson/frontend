{"componentChunkName":"component---src-templates-article-js","path":"/content/4fa644e5-2101-4788-abfe-d2d28d9ef0a0","result":{"data":{"content":{"contentId":"4fa644e5-2101-4788-abfe-d2d28d9ef0a0","title":"Changing object permissions in large S3 buckets","author":{"name":"alex"},"topics":[{"topicId":"491e6b8c-abac-5f70-b573-9ed982f02796","topic":"aws","slug":"/topic/aws"},{"topicId":"825ff086-8ce9-5c2f-aa1f-e8ef2e927ec3","topic":"golang","slug":"/topic/golang"}],"date":"Thu Nov 30 2017 20:44:00 GMT+0000 (Coordinated Universal Time)","image":{"image":null,"credit":null},"content":{"html":"<p>Of all of the services Amazon Web Services pushes, S3 (Simple Storage Service) is maybe the most versatile and well-known: It “just works” and is a fantastic service for many use-cases.\nIt turns out though that you can have too much of a good thing as many have learned <a href=\"https://www.theregister.co.uk/2017/03/01/aws_s3_outage/\">including Amazon</a>, and recently I have run into a reminder that S3’s API still leaves a little to be desired.</p>\n<h2>The problem</h2>\n<p>My use-case was pretty simple.  I had a bucket with about 2.5 million objects and needed to update the ACL on these objects to make them publicly readable.  Simple enough ... right?</p>\n<p>Usually I would approach such a task by changing the bucket policies to apply to all objects regardless of their own ACLs, yet here I did not have the option to change the bucket policies, and even so, this would have caused problems for any systems relying upon canned Object ACLs.</p>\n<h2>The solution</h2>\n<p>I wrote a small program in Go to recursively update S3 object permissions to any canned ACL.  It’s documented and downloadable here: <a href=\"https://github.com/alexwilson/s3-recursive-acl/\">https://github.com/alexwilson/s3-recursive-acl/</a></p>\n<p>I hope that this is useful as it stands, and I am keen to hear any suggestions on how I can improve the methodology (did I miss something?) as well as the program itself.</p>\n<p>Some more notes on how I came to this conclusion, and general thoughts on S3 and Golang after the break!</p>\n<hr>\n<h3>Attempt #1 — Read the docs</h3>\n<p>Amazon’s documentation is very comprehensive when you know where to look.  Sadly, I could not find anything that helped.  Ask around AWS practitioners and Solutions Architects the consensus was that I might need to write something custom to solve this problem.  Grr, but maybe there is something, and it's just buried deep within the docs!</p>\n<p>The file operations beneath the <code class=\"language-text\">aws s3</code>  command line, it makes sense that there’s nothing oriented towards modifying AWS ACL in here.  I was a bit disappointed that there was nothing beneath the S3API itself, however, as recursively changing permissions (still) seems like a reasonable use-case!</p>\n<p>I’m glad that the documentation is fairly conclusive, which is pretty refreshing given the spurious nature of documentation in competing services.  I’m hoping that a future version of the S3 API might introduce this functionality or something analogous to it!</p>\n<h3>Attempt #2 — Try to recursively update all Object metadata</h3>\n<p>This was a bit silly.  Various StackOverflow answers for tangentially related problems suggest that something like this might work:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"command-line-prompt\"><span data-user=alex data-host=localhost></span></span>aws s3 <span class=\"token function\">cp</span> <span class=\"token parameter variable\">--metadata</span> <span class=\"token assign-left variable\">FOO</span><span class=\"token operator\">=</span>bar <span class=\"token parameter variable\">--recursive</span> <span class=\"token parameter variable\">--acl</span> public-read <span class=\"token parameter variable\">--profile</span> test--prod s3://test-bucket-2/files/ s3://test-bucket-2/files/</code></pre></div>\n<p>It didn’t as no metadata was being changed.  It could have been an ideal approach as no API calls would need to be made from my machine for this operation to complete.</p>\n<h3>Attempt #3 — Start instrumenting the S3 API myself</h3>\n<p><code class=\"language-text\">putObjectAcl</code> is super nice as far as API methods go.  It’s a full PUT for a given object, but only for its metadata, so all I need to know is the key and the new ACL document.</p>\n<p>To save some time I started looking at the SDKs and quickly found the stellar work in the <a href=\"https://aws.amazon.com/sdk-for-go/\">Golang SDK</a>.\nIt’s got the same base functionality as other SDKs, but with nice features such as automatic pagination (which is a huge time-saver especially in AWS where pagination can be non-linear and involves keeping track of tokens) and not enforcing a particular concurrency model.</p>\n<p>This seemed ideal as it allowed me to implement a simplistic, yet elegant, approach:</p>\n<ol>\n<li>Iterate over pages of 1000 objects at a time, recursively listing by a given key.</li>\n<li>Spin-off Goroutines to run <code class=\"language-text\">putObjectACL</code> for each child key.</li>\n<li>Wait for the Goroutines to complete before exiting.</li>\n</ol>\n<p>I could’ve done something nicer here such as implementing a proper worker pool pattern, however, my batch sizes and concurrency requirements aren’t yet nearly large enough to justify this.  Maybe this is a possible improvement for the future!</p>\n<p>Goroutines were essential with this approach as it had to perform well. I effectively ran 2.5 thousand API calls to list the objects in this bucket and a further 2.5 million API calls to update those object permissions.</p>\n<p>And it ran <em>beautifully</em>.  In just over an hour all 2.5 million objects had the correct ACL!</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"command-line-prompt\"><span data-user=alex data-host=localhost></span></span><span class=\"token assign-left variable\">AWS_PROFILE</span><span class=\"token operator\">=</span>test--profile ./s3-recursive-acl <span class=\"token parameter variable\">--bucket</span> test-bucket-1 <span class=\"token parameter variable\">--region</span> ap-northeast-1 <span class=\"token parameter variable\">--path</span> test/</code></pre></div>\n<h4>Go-tchas</h4>\n<p>Not specific to this particular project, there are a few things in Golang that will definitely throw people off which I addressed whilst writing this.</p>\n<p>Passing pointers to Goroutines is very risky as the pointers can and will be reassigned.  <em>Always</em> make a copy of the true value you want first.  You can convert formats within the Goroutine itself if performance is a concern (in order not to block).</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">for</span> <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> object <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> page<span class=\"token punctuation\">.</span>Contents <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Make a copy of the value allocated to the pointer before we do anything with it!</span>\n    key <span class=\"token operator\">:=</span> <span class=\"token operator\">*</span>object<span class=\"token punctuation\">.</span>Key\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Goroutines logically run outside of the main scope of the application, and while this means sometimes they will run concurrently in the main thread, the application will not wait for Goroutines to complete, so you can’t guarantee that your operations will even run!</p>\n<p>Thankfully <a href=\"https://golang.org/pkg/sync/#WaitGroup\">WaitGroup</a> was added to the sync standard library to solve this problem, and it is ridiculously simple to get up and running with.</p>\n<p>Instantiate a WaitGroup, and instruct the application to block until the WaitGroup is terminated.  For every non-blocking operation that is spun up, increment the WaitGroup counter, and then reduce it when the operations complete.  This approach works well and has virtually no footprint.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\">// Create a WaitGroup</span>\n    <span class=\"token keyword\">var</span> wg sync<span class=\"token punctuation\">.</span>WaitGroup\n\n    <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token comment\">// Ask the WaitGroup to wait.</span>\n        wg<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\">// Do some work here.</span>\n\n        <span class=\"token comment\">// Tell the WaitGroup we're done</span>\n        <span class=\"token keyword\">defer</span> wg<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// Block until our tasks are done.</span>\n    wg<span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Wrap-up</h3>\n<p>I’m glad that S3 is this simple to orchestrate.  Being able to make this many Object Metadata changes this quickly (2.5 million objects in just over an hour?  That’s ~600req/s!) without being throttled is pretty spectacular. (I’m sure that running this actually within an EC2 in the same region would make this quicker)</p>\n<p>Also: Golang is invaluable for writing these super-performant scripts.  Every time I’ve had the chance to use it to tackle a problem, I’ve found it intuitive and quick to write and run.  I hope to have more of opportunities to use it in future work.  I’m thankful that I took the time to look at other options and languages first otherwise I wouldn’t have been done so quickly!</p>\n<p>I got a chance to try out the <a href=\"https://glide.sh/\">Glide packaging system</a> for this project, and it is really, <em>really</em> nice.  Recommended for projects of all shapes and sizes, and I will be using it for my future Golang hacks!</p>\n<p><a href=\"https://github.com/alexwilson/s3-recursive-acl/\">Download S3-recursive-acl here</a></p>","excerpt":"Of all of the services Amazon Web Services pushes, S3 (Simple Storage Service) is maybe the most versatile and well-known: It “just works…"},"slug":"/content/4fa644e5-2101-4788-abfe-d2d28d9ef0a0"},"site":{"siteMetadata":{"siteUrl":"https://alexwilson.tech"}}},"pageContext":{"contentId":"4fa644e5-2101-4788-abfe-d2d28d9ef0a0"}},"staticQueryHashes":["63159454","955950066"],"slicesMap":{}}